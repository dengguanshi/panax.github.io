{"posts":[{"title":"知识点--代理以及反射","content":"代理 一、理论 代理模式：提供一个代理对象，由代理对象控制真实对象的访问 静态代理 静态表示指定类的代理，代理代表内部维护一个真实对象的引用，在真实对象的前后进行操作 动态代理 动态代理是基于Java反射机制实现的，通过反射机制得到对象和方法，并进行操作 二、代码 静态代理快速实现 静态代理有实现一般为 代理接口 public interface MyObject { String name = null; void mind(); } 实现接口的真正对象 public class RealObject implements MyObject{ private String name; public void mind(){ System.out.println(&quot;富婆&quot;); } } 实现接口的代理类 public class StaticProxy implements MyObject{ MyObject object; public StaticProxy(MyObject object){ this.object = object; } @Override public void mind() { System.out.println(&quot;静态代理前操作&quot;); object.mind(); System.out.println(&quot;静态代理后操作&quot;); } } 动态代理实现 JDK动态代理 动态代理的实现是实现InvocationHandler接口，通过构造函数传入代理对象 public class MyProxy implements InvocationHandler { private String name; private Object BOSS; public MyProxy(Object object){ BOSS = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;打工打工……&quot;); Object result = method.invoke(BOSS,args); System.out.println(&quot;BOSS有钱了&quot;); return result; } } 调用，创建代理对象，传入不同的对象就可以代理不同的真实对象 public class Main { public static void main(String[] args) { InvocationHandler invocationHandler = new MyProxy(new RealObject()); MyObject object = (MyObject) Proxy.newProxyInstance(RealObject.class.getClassLoader(), RealObject.class.getInterfaces(),invocationHandler); object.mind(); } } cglib动态代理实现 ​ 对于cglib实现就是直接实现MetnodInterceptor接口，methodProxy.invokeSuper方法执行返回 /* * 基于cglib的代理类 * */ public class CglibProxy implements MethodInterceptor { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;cglib代理前&quot;); Object o1 = methodProxy.invokeSuper(o,objects); System.out.println(&quot;cglib代理后&quot;); return o1; } } ​ 调用的话需要使用Enhancer对象，通过创建一个继承与真实对象的代理对象进行使用 //基于cglib代理 CglibProxy cglibProxy = new CglibProxy(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(RealObject.class); enhancer.setCallback(cglibProxy); RealObject realObject = (RealObject) enhancer.create(); realObject.mind(); Class&lt;? extends RealObject&gt; classes = realObject.getClass(); Common.printMethods(classes); ​ 继承真实对象的cglib代理对象会附加多个代理方法可以使用 三、原理以及使用场景 静态代理借用接口实现多个真正对象和代理对象的分开，保证了代码的解耦性 但是同时，让类和接口增多，如果扩展接口或者类时，需要维护的就是两套代码 动态代理是借用的java反射机制，无需写源代码 动态代理是基于接口实现的，代理类会继承Proxy类，所以必须实现InvocationHandler接口 jdk的动态代理是静态代理的提取和升级，静态代理是每个真实对象都要生成一个代理对象，动态代理则是将代理对象提取成工厂类，使用工厂类动态创建对象的代理对象就行 对于spring AOP，如果该类存在接口，默认使用的代理的方式为jjdk的动态代理，如果没有实现接口的话，使用的是cglib，实现的原理就是继承真实对象，如果这个类没有实现接口，并标记为final类时，无法使用AOP代理 四、比较 1.Filter、Interceptor、AOP的区别是什么？ Filter过滤器 Interceptor拦截器 AOP切面 原理 函数回调 反射机制 动态代理 Interceptor 最先 其次 最后 管理范围 url规则匹配 url拦截，方法前后 类的元数据(类，方法，参数等) 适用场景 权限校验，设置编码 性能检测 日志 引用 细说Spring——AOP详解（动态代理实现AOP） spring aop原理 JDK动态代理和CGLIB动态代理 反射 一、理论 反射是Java中，在不方便通过new创建的时候，使用类的方法或者属性(protected属性等) 获取类有三种方法 Class.forName(类名) object.getClass() person.class 二、代码 我们可以通过反射获取到类的字段，属性，方法 /* * 打印该类的所有方法 * 使用方法为：Class&lt;? extends RealObject&gt; classes = realObject.getClass(); * Common.printMethods(classes); * */ public static void reflectPrintMethods(Class cl) { System.out.println(cl+&quot;的所有方法为：&quot;); //获得包含该类所有其他方法的数组 Method[] methods = cl.getDeclaredMethods(); //遍历数组 for (Method method : methods) { System.out.print(&quot; &quot;); //获得该方法的修饰符并打印 String modifiers = Modifier.toString(method.getModifiers()); if (modifiers.length() &gt; 0) { System.out.print(modifiers + &quot; &quot;); } //打印方法名 System.out.print(method.getName() + &quot;(&quot;); //获得该方法包含所有参数类型的Class对象的数组 Class[] paramTypes = method.getParameterTypes(); //遍历数组 for (int i = 0; i &lt; paramTypes.length; i++) { if (i &gt; 0) { System.out.print(&quot;,&quot;); } System.out.print(paramTypes[i].getName()); } System.out.println(&quot;);&quot;); } } /* * 根据类打印构造函数 * */ public static void printConstuctorMethods(Class cla){ System.out.println(cla+&quot;的所有构造函数为：&quot;); Constructor[]constructors = cla.getConstructors(); for (Constructor con: constructors) { //获取构造函数名 String name = con.getName(); //获取构造函数修饰语 String modifiers = Modifier.toString(con.getModifiers()); if (modifiers.length()&gt;0) { System.out.print(modifiers+ &quot; &quot;); } System.out.print(name+&quot;(&quot;); printMethodParameter(con.getParameterTypes()); System.out.println(&quot;);&quot;); } } /* * 根据多个类，打印函数中的参数 * */ public static void printMethodParameter(Class[] paramTypes){ for (int i = 0; i &lt; paramTypes.length; i++) { System.out.print(paramTypes[i].getName()); if (i&lt;paramTypes.length-1){ System.out.print(&quot;,&quot;); } } } /* * 打印可见的字段 * */ public static void printFields(Class clas){ Field [] fields = clas.getFields(); for (Field field : fields) { String fieldName = field.getName(); Class fieldType = field.getType(); String fieldTypeName = fieldType.getName(); System.out.println(fieldTypeName+&quot; &quot;+ fieldName); } } 不止是类的可见的属性，不可见的属性也可以查看得到，需要使用setAccessible方法开启属性 // 开启访问私有属性开关 field.setAccessible(true); 三、原理以及使用场景 ​ 反射是Java强大的机制，能够访问私有属性变量等，是因为Field，Method和Contructor类是有共同的父类AccessibleObject，类中的方法setAccessible就是可以关闭安全检查的开关 ​ 对于现阶段的我们，反射适用的地方就是比如在上次的山西的透传需求中的一个方案，本打算在服务端通过反射获取到请求类中的头信息对象，并重新自定义，再传递，只是请求类是使用的动态代理，没办法获取，如果遇到这种无法获取到类，或者不方便获取，可以尝试使用反射，通过反射获取类的信息 ","link":"https://myhomeme.github.io/6e9UCaI84/"},{"title":"知识点--dubbo以及RPC","content":"[TOC] 前言 ​ 我们现在维护的项目是ESB和HSF们对于HSF而言，就是我们改造了的dubbo框架,对于dubbo框架,最重要的也是RPC机制,原来公司使用的是ESB＋weblogic+tuxedo+服务一套调用各个服务,esb进行的统一的监控和管控,有较好的容纳性,随着服务的增加和日渐的多样化,定位问题变得更加繁琐,现大部分服务已经使用dubbo框架重写,由esb和zookeeper共同管理,并且基于dubbo的框架,有自己的一套治理中心,我们自己做的监控系统也集成了这个部分,dubbo相比于原来的架构而言,优势就是架构简单易懂,消费者生产者模式,容错性更强,监控运营也更加方便,通过zookeeper的机制随时监控各个服务的状态 RPC 1.理论知识 ​ 我们dubbo和esb的主要功能都是提供RPC服务(Remote ProcedureCall),远程过程调用,服务请求调用,使用HTTP协议就行了,像之前esb使用的就是http协议1.1,使用创建http客户端,发送请求报文到对应的机器上进行处理,但是为啥要替换成RPC了呢,因为针对与http报文传输,使用报文传输是文本编码,并且还有一些无用的头信息以及数据占用空间,比如dubbo的RPC就是使用的是自定义的TCP协议,能够提高传输数据的利用率,并且面对我们日常千万级流量的情况下,还需要一些高级的特性,流量监控,权限控制等等,在传输过程中提高利用率,在使用过程中提高效率,这也是使用RPC的原因 ​ RPC是远程过程调用,调用包括传输协议和序列化协议 传输协议可以是多中,谷歌的grpc是采用http2协议,dubbo使用的是自定义的tcp协议 序列化协议,常见的有基于文本编码的json协议,基于二进制的hessian协议(默认dubbo),esb使用的是webservice(soap文本协议) 2.代码 针对与dubbo,主要的组成部分有,接口,生产者,消费者,zookeeper 针对 那么如何具体实现dubbo框架的运行呢,我们通过编写一个服务的调用来理解框架的运行原理,虽然原来在学习的过程中也有实现过这部分代码,但是原理上并没有理解清楚,dubbo主要运用了Java的动态代理, \\ dubbo 1.理论知识 其核心部分包含: 远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 2.运维知识 dubbo+zookeeper模拟宕机后问题复现及解决办法-白红宇的个人博客 (css8.cn) 当zk集群超过半数宕机后，之前的服务都能正常使用，通过缓存取的服务信息 当zk集群超过半数宕机后，新的服务无法发布到集群中 当集群重新启动后，zk可以自动重连，但是消费者会在一段时间后报错，无法找到提供者，必须重启提供者才行，消费者不需要重启。 ","link":"https://myhomeme.github.io/DOiWDaLRj/"},{"title":"ADevOps分享","content":"[TOC] 背景 本站用于分享开发运维常用工具网站，分享本人工作生产 ","link":"https://myhomeme.github.io/adevops-fen-xiang/"}]}